"""
Integra√ß√£o com OpenAI GPT-4 Vision para an√°lise de documentos.
"""

from typing import Dict, List, Optional
import base64
import io
from PIL import Image
from openai import OpenAI
from app.core.config import settings


class OpenAIDocumentAnalyzer:
    """Classe para an√°lise de documentos usando OpenAI GPT-4 Vision."""
    
    def __init__(self):
        """Inicializa o cliente OpenAI."""
        if not settings.OPENAI_API_KEY:
            raise ValueError("OPENAI_API_KEY n√£o configurada no .env")
        
        # Inicializar cliente OpenAI
        self.client = OpenAI(
            api_key=settings.OPENAI_API_KEY,
            timeout=60.0,  # Aumentado para 60s
            max_retries=2
        )
        self.model_vision = settings.OPENAI_MODEL_VISION  # gpt-4o para imagens
        self.model_text = settings.OPENAI_MODEL_TEXT      # gpt-4o-mini para texto
        self.max_tokens = settings.OPENAI_MAX_TOKENS
        
        print(f"ü§ñ OpenAI configurado:")
        print(f"   ‚Ä¢ Modelo Vis√£o (imagens): {self.model_vision}")
        print(f"   ‚Ä¢ Modelo Texto (PDFs): {self.model_text}")
        print(f"   ‚Ä¢ Max Tokens: {self.max_tokens}")
    
    def analyze_document(
        self, 
        file_content: str, 
        file_type: str, 
        document_type: str,
        description: str = ""
    ) -> Dict:
        """
        Analisa um documento usando GPT-4 Vision.
        
        Args:
            file_content: Conte√∫do do arquivo em base64
            file_type: Tipo MIME do arquivo (image/jpeg, application/pdf, etc.)
            document_type: Tipo de documento (verify_identity, income_proof, etc.)
            description: Descri√ß√£o adicional do documento
        
        Returns:
            Dict com resultado da an√°lise
        """
        
        # Preparar prompt baseado no tipo de documento
        prompt = self._get_prompt_for_document_type(document_type, description)
        
        try:
            # Para imagens, usar GPT-4 Vision
            if file_type.startswith("image/"):
                return self._analyze_image(file_content, prompt, document_type)
            
            # Para PDFs, extrair texto e analisar
            elif file_type == "application/pdf":
                return self._analyze_pdf(file_content, prompt, document_type)
            
            else:
                return {
                    "valid": False,
                    "quality_score": 0,
                    "issues": ["Tipo de arquivo n√£o suportado"],
                    "confidence": 0,
                    "analysis": "Formato n√£o suportado para an√°lise"
                }
        
        except Exception as e:
            return {
                "valid": False,
                "quality_score": 0,
                "issues": [f"Erro na an√°lise: {str(e)}"],
                "confidence": 0,
                "analysis": "Erro ao processar documento"
            }
    
    def _analyze_image(self, base64_content: str, prompt: str, doc_type: str) -> Dict:
        """Analisa imagem usando GPT-4 Vision."""
        
        try:
            # Preparar mensagem com imagem
            messages = [
                {
                    "role": "system",
                    "content": """Voc√™ √© um especialista em an√°lise e valida√ß√£o de documentos financeiros e de identidade.
Sua fun√ß√£o √© avaliar a qualidade, autenticidade e legibilidade de documentos enviados.
Responda SEMPRE em JSON v√°lido com o formato especificado."""
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": prompt
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_content}",
                                "detail": "high"
                            }
                        }
                    ]
                }
            ]
            
            # Chamar API da OpenAI com modelo de vis√£o (gpt-4o)
            print(f"üì∏ Analisando imagem com {self.model_vision}...")
            response = self.client.chat.completions.create(
                model=self.model_vision,
                messages=messages,
                max_tokens=self.max_tokens,
                temperature=0.2,  # Baixa temperatura para respostas mais consistentes
                response_format={"type": "json_object"}
            )
            
            # Processar resposta
            import json
            result = json.loads(response.choices[0].message.content)
            
            # Normalizar resultado
            return self._normalize_llm_response(result, doc_type)
        
        except Exception as e:
            print(f"Erro ao analisar imagem: {e}")
            return {
                "valid": False,
                "quality_score": 0,
                "issues": [f"Erro na an√°lise: {str(e)}"],
                "confidence": 0,
                "analysis": "Erro ao processar imagem",
                "extracted_data": {}
            }
    
    def _analyze_pdf(self, base64_content: str, prompt: str, doc_type: str) -> Dict:
        """
        Analisa PDF extraindo texto e enviando para GPT-4.
        """
        
        try:
            from PyPDF2 import PdfReader
            import io
            
            # Decodificar PDF
            print(f"üìÑ Extraindo texto do PDF...")
            pdf_bytes = base64.b64decode(base64_content)
            pdf_file = io.BytesIO(pdf_bytes)
            
            # Extrair texto de todas as p√°ginas
            reader = PdfReader(pdf_file)
            text = ""
            
            for i, page in enumerate(reader.pages):
                page_text = page.extract_text()
                text += f"\n--- P√°gina {i+1} ---\n{page_text}"
            
            if not text.strip():
                print("‚ö†Ô∏è  Nenhum texto extra√≠do do PDF")
                return {
                    "valid": False,
                    "quality_score": 0,
                    "issues": ["PDF n√£o cont√©m texto leg√≠vel ou √© apenas imagem"],
                    "confidence": 100,
                    "analysis": "PDF sem texto extra√≠vel. Se for imagem escaneada, salve como JPG.",
                    "extracted_data": {}
                }
            
            print(f"‚úÖ Texto extra√≠do: {len(text)} caracteres de {len(reader.pages)} p√°gina(s)")
            
            # Limitar tamanho do texto (primeiros 8000 chars para n√£o estourar tokens)
            if len(text) > 8000:
                text = text[:8000] + "\n\n[... texto truncado ...]"
            
            # Preparar mensagens com texto extra√≠do
            messages = [
                {
                    "role": "system",
                    "content": """Voc√™ √© um analista de cr√©dito experiente e RIGOROSO.
Analise o texto extra√≠do deste documento PDF e retorne um JSON v√°lido com a valida√ß√£o."""
                },
                {
                    "role": "user",
                    "content": f"""{prompt}

TEXTO EXTRA√çDO DO PDF:
{text}

Analise RIGOROSAMENTE o texto acima e retorne o JSON conforme especificado."""
                }
            ]
            
            # Chamar API com modelo de texto (gpt-4o-mini)
            print(f"üìù Analisando texto com {self.model_text}...")
            response = self.client.chat.completions.create(
                model=self.model_text,
                messages=messages,
                max_tokens=self.max_tokens,
                temperature=0.2,
                response_format={"type": "json_object"}
            )
            
            import json
            result = json.loads(response.choices[0].message.content)
            
            return self._normalize_llm_response(result, doc_type)
        
        except ImportError:
            print("‚ùå PyPDF2 n√£o instalado")
            return {
                "valid": False,
                "quality_score": 0,
                "issues": ["PyPDF2 n√£o instalado - n√£o √© poss√≠vel processar PDFs"],
                "confidence": 100,
                "analysis": "Biblioteca PyPDF2 n√£o encontrada. Execute: pip install pypdf2",
                "extracted_data": {}
            }
        except Exception as e:
            print(f"‚ùå Erro ao analisar PDF: {e}")
            import traceback
            traceback.print_exc()
            return {
                "valid": False,
                "quality_score": 0,
                "issues": [f"Erro ao processar PDF: {str(e)}"],
                "confidence": 0,
                "analysis": f"Erro t√©cnico ao processar PDF: {str(e)}",
                "extracted_data": {}
            }
    
    def _get_prompt_for_document_type(self, document_type: str, description: str) -> str:
        """Gera prompt espec√≠fico para cada tipo de documento."""
        
        base_instruction = f"""Voc√™ √© um analista de cr√©dito experiente e RIGOROSO. Analise este documento com CRIT√âRIO CR√çTICO.

‚ö†Ô∏è IMPORTANTE: 
- Seja EXTREMAMENTE rigoroso na valida√ß√£o
- N√ÉO aceite documentos que n√£o sejam EXATAMENTE do tipo solicitado
- Se n√£o for o documento correto, retorne valid=false e quality_score=0
- Documentos irrelevantes devem receber nota ZERO

Retorne um JSON com os seguintes campos:
{{
    "valid": true/false,
    "quality_score": 0-100,
    "issues": ["lista DETALHADA de problemas"],
    "confidence": 0-100,
    "analysis": "an√°lise cr√≠tica e detalhada",
    "extracted_data": {{"dados extra√≠dos"}}
}}

Tipo de documento ESPERADO: {document_type}
Descri√ß√£o: {description}

"""
        
        if document_type == "verify_identity":
            return base_instruction + """
üìã DOCUMENTO ESPERADO: RG, CNH, RNE ou Passaporte brasileiro

‚úÖ CRIT√âRIOS OBRIGAT√ìRIOS (TODOS devem estar presentes):
1. ‚úì Deve ser documento de identidade oficial brasileiro
2. ‚úì Deve ter foto do titular vis√≠vel e n√≠tida
3. ‚úì Deve ter n√∫mero do documento claramente leg√≠vel
4. ‚úì Deve ter nome completo do titular
5. ‚úì Deve ter data de nascimento
6. ‚úì Deve ter √≥rg√£o emissor (SSP, DETRAN, etc)
7. ‚úì Deve ter data de emiss√£o
8. ‚úì Documento n√£o pode estar vencido (CNH)

‚ùå REJEITAR AUTOMATICAMENTE (valid=false, score=0):
- Documentos que N√ÉO s√£o RG/CNH/RNE
- Passaportes estrangeiros
- Carteiras profissionais (OAB, CRM, etc)
- Cart√µes de cr√©dito/d√©bito
- Documentos escolares/universit√°rios
- Fotos de pessoas sem documento oficial
- Documentos cortados ou parciais
- Documentos muito antigos ou deteriorados
- C√≥pias de m√° qualidade que impedem leitura

‚ö†Ô∏è PENALIZA√á√ïES NO SCORE:
- Foto desfocada: -20 pontos
- Campos ileg√≠veis: -30 pontos
- Ilumina√ß√£o ruim: -15 pontos
- Documento parcialmente vis√≠vel: -40 pontos
- Sinais de edi√ß√£o/adultera√ß√£o: valid=false, score=0

üìä PONTUA√á√ÉO RIGOROSA:
- 95-100: Documento PERFEITO (raro!) - foto HD, todos os campos cristalinos
- 85-94: Excelente qualidade - m√≠nimos problemas
- 70-84: Boa qualidade - alguns campos n√£o perfeitos
- 50-69: Qualidade aceit√°vel - v√°rios problemas mas identific√°vel
- 30-49: Qualidade ruim - dif√≠cil identifica√ß√£o
- 0-29: Inv√°lido/ileg√≠vel/documento errado

üîç EXTRAIR (se v√°lido):
- document_type: "RG" | "CNH" | "RNE"
- document_number: "XX.XXX.XXX-X"
- full_name: "Nome completo"
- birth_date: "DD/MM/AAAA"
- issuer: "SSP-UF" ou "DETRAN-UF"
- issue_date: "DD/MM/AAAA"
"""
        
        elif document_type == "income_proof":
            return base_instruction + """
üìã DOCUMENTO ESPERADO: Holerite, Contracheque, DECORE (contador), Pr√≥-labore, DRE (empresa)

‚úÖ CRIT√âRIOS OBRIGAT√ìRIOS (TODOS devem estar presentes):
1. ‚úì Deve ser comprovante de renda OFICIAL
2. ‚úì Deve ter valor de renda claramente identific√°vel (sal√°rio bruto/l√≠quido)
3. ‚úì Deve ter nome do empregador ou fonte pagadora (pode estar no cabe√ßalho)
4. ‚úì Deve ter nome do benefici√°rio/empregado
5. ‚úì Deve ter data/per√≠odo de refer√™ncia (m√™s/ano)
6. ‚úì Para holerite: deve ter descontos t√≠picos (INSS, IR, etc)
7. ‚úì Para DECORE: deve ter carimbo e assinatura de contador com CRC
8. ‚úì Documento deve ter estrutura t√≠pica de folha de pagamento

‚ùå REJEITAR AUTOMATICAMENTE (valid=false, score=0):
- Documentos que N√ÉO s√£o comprovantes de renda
- Extratos banc√°rios simples (sem identifica√ß√£o de sal√°rio)
- Notas fiscais de produtos/servi√ßos
- Notas t√©cnicas, documentos administrativos, artigos
- Print de tela de apps/sites sem valida√ß√£o oficial
- Comprovantes estrangeiros
- Documentos sem valor de renda identific√°vel
- Documentos claramente irrelevantes para an√°lise de renda

‚ö†Ô∏è PENALIZA√á√ïES NO SCORE:
- Valores parcialmente ileg√≠veis: -30 pontos
- Falta carimbo/assinatura (DECORE): -40 pontos
- Qualidade de imagem ruim: -20 pontos
- Documento cortado ou parcial: -25 pontos
- Formata√ß√£o n√£o profissional: -15 pontos

üìä PONTUA√á√ÉO RIGOROSA:
- 95-100: Holerite perfeito, todos os campos vis√≠veis e leg√≠veis
- 85-94: Comprovante oficial completo e claro
- 70-84: Comprovante v√°lido mas com pequenas falhas de qualidade
- 50-69: Comprovante com problemas significativos mas identific√°vel
- 30-49: Comprovante duvidoso ou muito problem√°tico
- 0-29: N√£o √© comprovante v√°lido ou ileg√≠vel

‚ö†Ô∏è IMPORTANTE SOBRE DATAS:
- N√ÉO rejeite apenas pela data se o documento for claramente um holerite v√°lido
- A data deve ser usada apenas para avaliar a ATUALIDADE, n√£o a validade
- Um holerite leg√≠timo com todos os campos √© v√°lido independente da data
- Penalize pela antiguidade, mas N√ÉO rejeite automaticamente

üîç EXTRAIR (se v√°lido):
- document_type: "Holerite" | "DECORE" | "Pr√≥-labore" | "DRE"
- monthly_income: valor num√©rico (R$)
- annual_income: valor num√©rico (R$) se dispon√≠vel
- employer: "Nome da empresa/empregador"
- employee_name: "Nome do benefici√°rio"
- reference_period: "MM/AAAA"
- issue_date: "DD/MM/AAAA"
- gross_income: valor bruto
- net_income: valor l√≠quido
"""
        
        elif document_type == "tax_declaration":
            return base_instruction + """
üìã DOCUMENTO ESPERADO: Declara√ß√£o de Imposto de Renda (DIRPF) - Recibo de entrega da Receita Federal

‚úÖ CRIT√âRIOS OBRIGAT√ìRIOS (TODOS devem estar presentes):
1. ‚úì Deve ser recibo oficial da Receita Federal do Brasil
2. ‚úì Deve ter n√∫mero do recibo de entrega
3. ‚úì Deve ter CPF do declarante
4. ‚úì Deve ter nome completo do declarante
5. ‚úì Deve ter ano-calend√°rio da declara√ß√£o
6. ‚úì Deve ter data de entrega
7. ‚úì Deve ser dos √öLTIMOS 2 ANOS (ano atual ou anterior)
8. ‚úì Deve ter resumo de rendimentos tribut√°veis

‚ùå REJEITAR AUTOMATICAMENTE (valid=false, score=0):
- Documentos que N√ÉO s√£o declara√ß√£o de IR oficial
- Comprovantes de situa√ß√£o cadastral CPF (n√£o √© declara√ß√£o)
- Extratos de IRRF retido na fonte
- Declara√ß√µes com mais de 2 anos
- Prints de tela sem recibo oficial
- Declara√ß√µes em processamento (sem recibo)
- Declara√ß√µes estrangeiras
- Rascunhos ou declara√ß√µes n√£o enviadas

‚ö†Ô∏è PENALIZA√á√ïES NO SCORE:
- Declara√ß√£o do ano anterior: -10 pontos
- Declara√ß√£o de 2 anos atr√°s: -30 pontos
- Campos importantes ileg√≠veis: -40 pontos
- Sem n√∫mero de recibo vis√≠vel: -50 pontos
- Documento cortado/incompleto: -60 pontos

üìä PONTUA√á√ÉO RIGOROSA:
- 95-100: Declara√ß√£o do ano atual, completa, recibo leg√≠vel
- 85-94: Declara√ß√£o recente e bem documentada
- 70-84: Declara√ß√£o v√°lida do ano anterior
- 50-69: Declara√ß√£o de 2 anos com dados vis√≠veis
- 30-49: Declara√ß√£o muito antiga ou incompleta
- 0-29: N√£o √© declara√ß√£o v√°lida

üîç EXTRAIR (se v√°lido):
- document_type: "DIRPF"
- tax_year: ano-calend√°rio (ex: 2024)
- receipt_number: n√∫mero do recibo
- cpf: "XXX.XXX.XXX-XX"
- taxpayer_name: "Nome completo"
- submission_date: "DD/MM/AAAA"
- total_income: valor total de rendimentos
- tax_paid: imposto pago/restitu√≠do
"""
        
        elif document_type == "utility_bills":
            return base_instruction + """
üìã DOCUMENTO ESPERADO: Conta de Luz, √Ågua, G√°s, Telefone fixo/internet (utilidades p√∫blicas)

‚úÖ CRIT√âRIOS OBRIGAT√ìRIOS (TODOS devem estar presentes):
1. ‚úì Deve ser conta de servi√ßo p√∫blico/utilidade
2. ‚úì Deve ter nome da concession√°ria (ex: ENEL, SABESP, Oi)
3. ‚úì Deve ter endere√ßo completo de instala√ß√£o
4. ‚úì Deve ter nome do titular da conta
5. ‚úì Deve ter data de vencimento
6. ‚úì Deve ter valor a pagar
7. ‚úì Deve ter n√∫mero de instala√ß√£o/matr√≠cula

‚ùå REJEITAR AUTOMATICAMENTE (valid=false, score=0):
- Documentos que N√ÉO s√£o contas de utilidades
- Boletos de outros servi√ßos (cart√£o, empr√©stimos, etc)
- Contas de celular pr√©-pago (n√£o serve como comprovante)
- Contas em nome de terceiros sem v√≠nculo
- Prints de segunda via sem dados completos
- Faturas de TV por assinatura/streaming

‚ö†Ô∏è PENALIZA√á√ïES NO SCORE:
- Conta mais antiga: -10 a -20 pontos conforme idade
- Endere√ßo parcialmente vis√≠vel: -30 pontos
- Nome do titular ileg√≠vel: -40 pontos
- Conta em nome de terceiro: valid=false, score=0
- Sem data de vencimento clara: -20 pontos

üìä PONTUA√á√ÉO RIGOROSA:
- 95-100: Conta recente, todos os dados leg√≠veis
- 85-94: Conta completa e clara
- 70-84: Conta v√°lida com pequenas falhas
- 50-69: Conta mais antiga ou campos ileg√≠veis
- 30-49: Conta com dados incompletos
- 0-29: N√£o √© conta v√°lida de utilidade

üîç EXTRAIR (se v√°lido):
- utility_type: "Luz" | "√Ågua" | "G√°s" | "Telefone/Internet"
- provider: "Nome da concession√°ria"
- holder_name: "Nome do titular"
- address: "Endere√ßo completo de instala√ß√£o"
- reference_month: "MM/AAAA"
- due_date: "DD/MM/AAAA"
- amount: valor num√©rico (R$)
- installation_number: "N√∫mero da instala√ß√£o"
"""
        
        elif document_type == "bank_statement":
            return base_instruction + """
üìã DOCUMENTO ESPERADO: Extrato Banc√°rio oficial

‚úÖ CRIT√âRIOS OBRIGAT√ìRIOS (TODOS devem estar presentes):
1. ‚úì Deve ser extrato banc√°rio oficial de institui√ß√£o financeira
2. ‚úì Deve ter logo/nome do banco
3. ‚úì Deve ter nome do titular da conta
4. ‚úì Deve ter n√∫mero da ag√™ncia e conta
5. ‚úì Deve ter per√≠odo do extrato
6. ‚úì Deve ter movimenta√ß√µes financeiras (entrada/sa√≠da)
7. ‚úì Deve ter saldo inicial e final

‚ùå REJEITAR AUTOMATICAMENTE (valid=false, score=0):
- Prints de apps sem valida√ß√£o oficial
- Extratos de contas inativas
- Documentos sem identifica√ß√£o do banco
- Extratos sem movimenta√ß√µes
- Extratos de terceiros

‚ö†Ô∏è PENALIZA√á√ïES NO SCORE:
- Extrato mais antigo: -10 a -20 pontos
- Sem movimenta√ß√µes relevantes: -30 pontos
- Dados parcialmente vis√≠veis: -40 pontos
- Sem logo do banco: -20 pontos

üìä PONTUA√á√ÉO RIGOROSA:
- 95-100: Extrato oficial com movimenta√ß√µes claras
- 85-94: Extrato completo e leg√≠vel
- 70-84: Extrato v√°lido com pequenas falhas
- 50-69: Extrato mais antigo ou incompleto
- 0-29: N√£o √© extrato v√°lido

üîç EXTRAIR (se v√°lido):
- bank_name: "Nome do banco"
- holder_name: "Nome do titular"
- account_number: "Ag√™ncia-Conta"
- period_start: "DD/MM/AAAA"
- period_end: "DD/MM/AAAA"
- opening_balance: valor inicial
- closing_balance: valor final
"""
        
        else:  # custom
            return base_instruction + """
üìã DOCUMENTO ADICIONAL/COMPLEMENTAR

‚ö†Ô∏è ATEN√á√ÉO: Este tipo aceita documentos complementares, mas ainda assim devem ser RELEVANTES para an√°lise de cr√©dito.

‚úÖ ACEITAR SE:
- Contrato de trabalho assinado
- Comprovante de v√≠nculos profissionais
- Certid√µes negativas (d√≠vidas, protestos)
- Comprovantes de patrim√¥nio
- Documentos societ√°rios (empresa)

‚ùå REJEITAR (valid=false, score=0):
- Documentos completamente irrelevantes (notas t√©cnicas, artigos, manuais)
- Documentos pessoais sem rela√ß√£o com cr√©dito
- Fotos aleat√≥rias
- Documentos de terceiros n√£o relacionados
- Arquivos corrompidos ou ileg√≠veis

üìä PONTUA√á√ÉO RIGOROSA:
- 90-100: Documento complementar muito relevante
- 70-89: Documento √∫til para an√°lise
- 50-69: Documento com relev√¢ncia limitada
- 30-49: Documento de baixa relev√¢ncia
- 0-29: Documento irrelevante ou inv√°lido

üîç EXTRAIR:
- document_description: descri√ß√£o do que √©
- relevance: "Alta" | "M√©dia" | "Baixa"
- key_information: informa√ß√µes principais
"""
    
    def _normalize_llm_response(self, llm_result: Dict, doc_type: str) -> Dict:
        """Normaliza a resposta do LLM para o formato esperado."""
        
        return {
            "valid": llm_result.get("valid", False),
            "quality_score": max(0, min(100, llm_result.get("quality_score", 0))),
            "issues": llm_result.get("issues", []),
            "confidence": max(0, min(100, llm_result.get("confidence", 0))),
            "analysis": llm_result.get("analysis", ""),
            "extracted_data": llm_result.get("extracted_data", {})
        }
